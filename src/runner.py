import copy
import json
import itertools
from pathlib import Path
import pandas as pd
from src.config_manager import ConfigManager
from src.strategy import Strategy

interval_map = {
    "daily": "1d",
    "weekly": "1wk",
    "monthly": "1mo"
}


def load_configuration(config_path: Path, run_id: str) -> dict:
    """
    Loads the configuration for a specific run ID.

    Args:
        run_id (str): The ID of the run configuration to load.

    Returns:
        dict: The loaded configuration parameters.
    """

    try:
        config_manager = ConfigManager(
            run_config_path=config_path / "run_config.json",
            strategies_config_path=config_path / "strategies.json",
            indicators_config_path=config_path / "indicators.json",
        )
        config: dict = config_manager.load_combined_config(run_id)

        # Convert human-readable timeframe to yfinance interval
        timeframe = config.get("timeframes", ["daily"])[0]
        config["new_timeframe"] = interval_map.get(
            timeframe.lower(), timeframe)

        return config
    except (FileNotFoundError, ValueError) as e:
        print(f"Error loading configuration: {e}")
        raise
    except KeyError as e:
        print(f"Missing key in configuration: {e}")
        raise
    except Exception as e:
        print(f"Unexpected error loading configuration: {e}")
        raise


def apply_strategy(data: pd.DataFrame, config: dict) -> pd.DataFrame:
    """
    Applies the selected strategy to the data.

    Args:
        config (dict): Configuration dictionary.
        data (pd.DataFrame): Market data.

    Returns:
        pd.DataFrame: Signals generated by the strategy.
    """
    strategy_functions = {
        "rsi_ema_crossover": Strategy.apply_rsi_ema_crossover,
        "moving_average_crossover": Strategy.apply_moving_average_crossover,
    }

    strategy_type = config.get("strategy_type", "").lower()
    strategy_func = strategy_functions.get(strategy_type)

    if not strategy_func:
        raise ValueError(f"Strategy type '{config.get('strategy_type')}'" +
                         "is not defined or supported")

    strategy_params = config.get("strategy_params", {})
    print(
        f"Applying strategy: {
            config['strategy_id']} with parameters: {strategy_params}")
    signals = strategy_func(data_frame=data, params=strategy_params)
    print(f"Successfully applied strategy: {config['strategy_id']}")
    return signals


def generate_param_combinations(config: dict):
    """
    Generates all possible strategy parameter combinations
    based on optimization rules. Yields a full config
    dictionary for each parameter set.

    Args:
        config_json: A JSON dict containing the strategy configuration.

    Yields:
        A dictionary representing one combination of strategy parameters.
    """

    if "optimization_params" not in config:
        print("Warning: Optimizer mode run, but 'optimization_params' not found in config. Running with base params only.")
        yield config
        return

    # Assuming there is only one strategy key, e.g., "RSI_EMA_Crossover"

    base_params = config["strategy_params"]
    opt_params = config["optimization_params"]

    # Prepare lists of parameter names and their corresponding value iterables
    param_names = []
    value_iterables = []

    # Process range-based parameters
    for key, value in opt_params.get("range", {}).items():
        param_names.append(key)
        value_iterables.append(
            range(
                value[0],
                value[1] + 1,
                value[2] if len(value) > 2 else 1))

    # Process options-based parameters
    for key, value in opt_params.get("options", {}).items():
        param_names.append(key)
        value_iterables.append(value)

    if not param_names:
        print("Warning: 'optimization_params' found, but no valid 'range' or 'options' defined.")
        yield config
        return

    # Generate all combinations using itertools.product
    all_combinations = itertools.product(*value_iterables)

    nconfig = copy.deepcopy(config)
    # Create a new parameter dictionary for each combination
    for combination in all_combinations:
        # Create a dictionary for the current combination of optimized
        # parameters
        current_opt_params = dict(zip(param_names, combination))

        # Update the strategy_params with the current combination
        nconfig["strategy_params"].update(current_opt_params)
        yield nconfig


def __set_test():
    json_config = """
    {
        "ticker": "AAPL",
        "strategy_type": "RSI_EMA_Crossover",
        "strategy_params": {
        "rsi_threshold": 50,
        "RSI_Period": 14,
        "MA_Period": 9,
        "MA_TYPE": "EMA"
        },
        "optimization_params": {
        "range": {
            "RSI_Period": [5, 7],
            "MA_Period": [5, 6]
        },
        "options": {
            "MA_TYPE": ["EMA", "SMA"]
        }
        }
    }
    """
    config = json.loads(json_config)
    param_generator = generate_param_combinations(config)

    print("--- Generated Parameter Combinations ---")
    # Iterate through the generator and print each combination
    for i, params in enumerate(param_generator):
        print(f"Combination {i + 1}: {params}")


if __name__ == "__main__":
    __set_test()
