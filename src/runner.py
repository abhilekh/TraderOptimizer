import argparse
import copy
import itertools
from pathlib import Path

import pandas as pd
from src.config_manager import ConfigManager
from src.strategy import Strategy
from src.utils import Utils

interval_map = {
            "daily": "1d",
            "weekly": "1wk",
            "monthly": "1mo"
        }



def load_configuration(config_path: Path, run_id: str, run_optimizer: bool) -> dict:
    """
    Loads the configuration for a specific run ID.

    Args:
        run_id (str): The ID of the run configuration to load.

    Returns:
        dict: The loaded configuration parameters.
    """

    try:
        config_manager = ConfigManager(
            run_config_path=config_path / "run_config.json",
            strategies_config_path=config_path / "strategies.json",
            indicators_config_path=config_path / "indicators.json",
        )
        config: dict = config_manager.load_combined_config(run_id)
        
        myinterval: str = interval_map.get(config["timeframes"][0].lower(), str(config["timeframes"][0]))
        config["new_timeframe"] = myinterval
        # Run run_optimizer and check        
        return config
    except (FileNotFoundError, ValueError) as e:
        print(f"Error loading configuration: {e}")
        raise
    except KeyError as e:
        print(f"Missing key in configuration: {e}")
        raise
    except Exception as e:
        print(f"Unexpected error loading configuration: {e}")
        raise


def apply_strategy(data: pd.DataFrame, config: dict) -> pd.DataFrame:
    """
    Applies the selected strategy to the data.

    Args:
        config (dict): Configuration dictionary.
        data (pd.DataFrame): Market data.

    Returns:
        pd.DataFrame: Signals generated by the strategy.
    """
    strategy_functions = {
        "rsi_ema_crossover": Strategy.apply_rsi_ema_crossover,
        "moving_average_crossover": Strategy.apply_moving_average_crossover,
    }
    strategy_func = strategy_functions.get(config["strategy_type"].lower())
    if not strategy_func:
        raise ValueError(f"Strategy type '{config['strategy_type']}' is not defined.")

    strategy_params = config.get("strategy_params", {})
    print(f"Applying strategy: {config['strategy_id']} with parameters: {strategy_params}")
    signals = strategy_func(data_frame=data, params=strategy_params)
    print(f"Successfully applied strategy: {config['strategy_id']}")
    return signals

def save_results(portfolio: pd.DataFrame, signals: pd.DataFrame, output_path: Path, config: dict):
    """
    Saves the backtest results and trades to the specified output path.

    Args:
        portfolio (pd.DataFrame): Portfolio DataFrame with backtest results.
        trades (pd.DataFrame): Trades DataFrame.
        output_path (Path): Path to save the results.
        config (dict): Configuration dictionary.
    """
    filename_prefix = f"backtest_{config['ticker']}_{config['strategy_id']}_{config['new_timeframe']}"

    # Save trades
    trades_filepath = output_path / f"{filename_prefix}_trades.csv"
    portfolio.to_csv(trades_filepath)
    print(f"Trade log saved to: {trades_filepath}")
    
    #Save plot
    plot_filepath = output_path / f"{filename_prefix}_plot.png"
    params = config.get("indicators", {})
    timeframe = config["timeframes"][0]
    Utils.plot_results(
        df_results=portfolio,
        df_signals=signals,
        initial_capital=config.get("initial_capital", 10000.0),
        ticker=config["ticker"],
        params=params,
        timeframe=timeframe,
        output_filepath=str(plot_filepath)
    )
    print(f"Equity curve plot saved to: {plot_filepath}") 



def generate_param_combinations(config: dict):
    """
    Generates all possible strategy parameter combinations based on optimization rules.

    Args:
        config_json: A JSON dict containing the strategy configuration.

    Yields:
        A dictionary representing one combination of strategy parameters.
    """
    
    # Assuming there is only one strategy key, e.g., "RSI_EMA_Crossover"

    nconfig = copy.deepcopy(config)
    base_params = config["strategy_params"]
    opt_params = config["optimization_params"]

    # Prepare lists of parameter names and their corresponding value iterables
    param_names = []
    value_iterables = []

    # Process parameters with a defined range
    if "range" in opt_params:
        for key, value in opt_params["range"].items():
            param_names.append(key)
            # Create an iterable from the start to the end of the range (inclusive)
            value_iterables.append(range(value[0], value[1] + 1))

    # Process parameters with a list of options
    if "options" in opt_params:
        for key, value in opt_params["options"].items():
            param_names.append(key)
            value_iterables.append(value)

    # Generate all combinations using itertools.product
    all_combinations = itertools.product(*value_iterables)

    # Create a new parameter dictionary for each combination
    for combination in all_combinations:
        # Start with a fresh copy of the non-optimized base parameters
        new_params = {k: v for k, v in base_params.items() if k not in param_names}
        
        # Create a dictionary for the current combination of optimized parameters
        current_opt_params = dict(zip(param_names, combination))
        
        # Merge the base and optimized parameters
        new_params.update(current_opt_params)
        
        nconfig["strategy_params"] = new_params
        yield nconfig


def __set_test():
    json_config = """
    {
        "ticker": "AAPL",
        "strategy_type": "RSI_EMA_Crossover",
        "strategy_params": {
        "rsi_threshold": 50,
        "RSI_Period": 14,
        "MA_Period": 9,
        "MA_TYPE": "EMA"
        },
        "optimization_params": {
        "range": {
            "RSI_Period": [5, 7],
            "MA_Period": [5, 6]
        },
        "options": {
            "MA_TYPE": ["EMA", "SMA"]
        }
        }
    }
    """
    import json
    config = json.loads(json_config)
    param_generator = generate_param_combinations(config)

    print("--- Generated Parameter Combinations ---")
    # Iterate through the generator and print each combination
    for i, params in enumerate(param_generator):
        print(f"Combination {i+1}: {params}")


if __name__ == "__main__":
    __set_test()

